# Segmentation
- Address space에 free space가 너무 많아도, 그걸 인지 못하고 free space가 물리 공간을 그만큼 차지하고있음
- Stack이나 Heap이 꽉 찼을때는? -> 보통 늘려주는 방안
- base&bound를 가지는 code/stack/heap를 각각 다른 물리적 공간 배치한다 -> 각자 다른 물리적 공간에 존재 해도됨
## Physical Address
- physical address = offset + base
- virtual address + base =
- 해당 segment의 범위를 벗어난 공간에 접근을 시도 할 경우, segmentation fault error가 발생함(out of bounds)
- 가상주소의 상위 2 비트는 세그먼트(00, 01, 10, 11에서 code/heap/stack 3개 분배), 나머지는 오프셋으로 사용
- 스택은 위로 커지고, 코드와 힙은 밑으로 커짐
## Fragmentation(조각)
- External Fragementation : 중간중간 작은 free space -> 합쳐지면 segment 사용가능
- Compaction : free space들을 찾아서 재배치 해주는 과정 -> 비용이 많이 듬
  (프로세스 정지, 데이터 복사(임시), segment 레지스터 값 재조정)

# Free Space Management
## Spliting
- 요청을 처리 할 수 있는 공간을 찾아서 반으로 가르는 것
- 메모리 할당요청량이 남아있는 free space보다 작을 때 수행
- Free list는 링크드 리스트로 관리
## Coalescing
- 남아있는 독립 공간에 비해 메모리 할당 요청량이 큰 경우
- 흩어져있는 free chunk들을 하나로 합침(서로 주소가 가까운 경우)
- free() 함수의 파라미터는 size가 없다 -> 처음 공간을 할당 받을 때, 헤더(할당한 공간보다 전에 저장)에 사이즈를 저장해 둠(헤더의 사이즈도 포함된 값)
## Free List
- 헤더는 할당된 메모리 사이즈가 저장 돼있고, 추가적인 포인터나, 완전성 확인을 위한 magic 넘버를 저장해두기도 함
- 처음 공간을 할당 할 때 free list를 만듬(첫번째 값과 함께)
- 일정량의 메모리 할당 요청을 받으면, 그 만한 요청을 처리 할 수 있을만한 크기의 free chunk를 찾음
  -> 해당 chunk를 split한 후, free list 값 갱신
- 대부분의 할당자들은 작은 heap을 생성 한 후 점점 늘리는 방식을 선택
## Strategies
- Best-Fit : 요청량이랑 같거나 큰 chunk들을 찾음 -> 이중에서 가장 작은 chunk를 반환 
- Worst-Fit : 남은 free chunk들 중 가장 큰 청크들 중 하나를 반환
- First-Fit : 남은 free chunk중 요청량을 충족하는 가장 첫 chunk를 찾은 후 반환
- Next-Fit : 전에 할당했던 곳에서 시작해, 해당 주소 다음에 있는 chunk들 중 할당량에 맞는 첫 chunk를 반환
## Segregated List
- 빈 공간 덩어리들을 size별로 다른 리스트에 저장 -> 여기에 얼마나 많은 메모리를 할당해야하는가? -> slab allocator가 해결
## Slab allocator
- 몇개의 객체 캐시를 할당함 -> 자주 호출 될 확률이 높은 객체들 (ex) locks, file-system inodes
- 해당 캐시가 빈 공간을 다 써갈때 다른 메모리 할당자에서 메모리 요청
## Buddy Allocation
- 할당 요청만큼 작아질때까지 빈공간을 계속해서 반으로 가름
- internal fagmentation 발생 가능성이 높음
- coalescing이 간단해짐 (바로 옆에옆에 있음)
