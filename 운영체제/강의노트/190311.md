# CPU Virtualizing
- OS가 수많은 가상의 CPU가 존재하는 것처럼 보이게 함
- Time Sharing 기법 : 한번에 하나의 프로세스를 실행하고, 작업을 멈췄다가 다른 작업을 실행하다가 돌아오고를 반복
  -> 멀티태스킹 하는 것처럼 보임
- Context Switch(문맥 교환) : OS가 한 프로그램 실행을 멈추고 다른 프로그램을 실행했다가 왔다갔다 하는거
- Policy : OS가 어떤 프로그램을 먼저 실행할지 정하는 알고리즘

# Process
- Running Program
## Memory
- instructions(code)
- data section
## Registers
- program counter(PC)
- **Stack Pointer** -> 프로그램의 실행 상태 저장(함수)

# Process API
- Create : create a new process to run a program
- Destroy : halt a runaway process
- Wait : wait for a process to stop running
- Miscellaneous Control : some kind of method to suspend a process and then resume
- Status : get some status info about a process

# Process Creation
1. 메모리로부터 exe형태의 프로그램 코드를 Loading 해옴 (Disk -> Memory(address space))
  -> 필요한 code/data만 로딩해옴
2. 프로그램의 Stack이 할당 됨(지역 변수, 인수, 반환 주소 등을 저장)
  -> 초기화는 argc, argv로 채움 (main 함수의 인자)
3. 프로그램 Heap가 생성 됨 (동적 할당을 위한 공간 ex) malloc())
4. 다른 초기화 작업 진행 (I/O 셋업 - 프로세스는 3가지 file descriptor가 있음 : Input / Output / Error)
5. 프로그램 시작(main() 함수) - CPU 컨트롤을 해당 프로세스로 넘김

# Process States
- Running : 프로세스가 현재 실행중
- Ready : 프로세스가 실행 준비를 마쳤지만, OS는 다른 프로세스를 실행중인 상황
- Blocked : 프로세스가 특정 연사 수행을 요청해서(I/O 작업 요청) 다른 프로세스로 흐름이 넘겨 간 상황
  -> 해당 I/O 작업이 끝나면 다시 Ready 상태가 됨

# Data Structures
## Process List
- Ready 상태의 프로세스들
- Blocked 상태의 프로세스들 : 종료시 다시 Ready로 감
- Current Running Process
## Register context
- Context Switch 와 관련 ...
- 프로세스가 정지 했을 때 해당 레지스터에 저장, 레지스터를 반납하면서 프로세스 다시 시작
