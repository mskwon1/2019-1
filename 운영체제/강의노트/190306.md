- CPU에게 명령을 내리는 건 사람이다
- CPU는 시킨 일만 빠르게 빠르게 처리(명령을 받아서, 해석하고, 실행 -> 반복)
# OS의 역할 : 시스템이 바르고, 효율적으로 돌아가도록 함
- 프로그램 실행이 쉽게 되도록 함
- 프로그램이 메모리를 쓸 수 있도록 함
- 프로그램이 장치와 상호작용하도록
## Virtualization
- 물리적 자원을 가상의 자원으로 바꿔서 프로그램이 쓸 수 있도록 하는 것
- 물리적 자원 ex) processor, memory, disk
- 가상의 자원이 훨씬 일반적이고, 강력하고 사용하기 쉬움
- OS자체가 Virtual Machine이라고 볼 수도 있음
## System call
- 사용자가 운영체제에게 명령을 할 수 있도록 도와줌
- OS가 인터페이스를 제공 ex) API, 표준 라이브러리
- ex) 프로그램 실행, 메모리 접근, 장비 접근
## Resource Manager(자원 관리자)
- OS는 CPU, memory, disk 등의 자원을 관리함
- 프로그램 실행 = CPU sharing
- 동시다발적으로 여러 프로그램 실행하기 = Memory sharing
- 프로그램에 장치 접근권한 붑여 = Disk sharing
## CPU의 Virtualization
- 하나의 CPU를 여러개의 CPU가 있는 것 처럼 보이게 하는 것
- 프로그램이 여러개의 CPU를 사용하는 것 처럼 보이게 함
- 멀티태스킹 하는 것처럼 보이지만, 실제로는 돌아가면서 씀
## Memory의 Virtualization
- 물리적 메모리는 바이트의 배열임(주소값)
- Read : 주소값에서 데이터를 불러옴
- Write : 주소값에 데이터를 씀
- 프로그램에서 메모리 할당을 요청하면, 프로그램은 Private하고 독립적인 메모리 공간을 할당 받음
- 같은 프로그램을 동시에 여러개 실행해도,
  각 프로그램이 갖는 메모리 공간은 모두 다름(겉으로 나오는 주소 출력값이 같을 수 있지만, 실제 물리적 주소는 다름)
### Thread : 실행 흐름
- 동시에 여러 프로그램을 돌릴 수 있게 해줌
- C++에서 ptrhead_t 타입의 스레드 변수 선언가능,
  pthread_create(스레드 변수, NULL, worker, NULL)의 형식으로 스레드 생성가능 -> 고유한 아이디가 주어지고, 스레드 별로 메모리 공간이 따로 할당
- 멀티스레드로 같은 작업을 많이 반복시켰을 때, instruction이 똑바로 실행 안되는 경우가 있음
  -> 서로 다른 스레드에서 실제 디스크에 있는 변수에 load - add - store의 연산을 하다보니 연산이 완료되지 않고 다른 스레드에서 해당 변수를 건드리는 상황 발생 할 수 있음 -> 이 경우에는 instruction을 atomic하게 만들어줘야함
- 대신, 실행 횟수가 적은경우에는 CPU가 sequential하게 실행
## Design Goals
- Abstraction
- Performance
- Protection
- Reliability
